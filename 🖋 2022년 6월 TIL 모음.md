## 🖋 2022-06-27 (월) - TIL


### 단방향 Linked List의 모든 요소 삭제
```swift
    func removeAll() {
        head = nil
    }
```
- 단방향 리스트는 각 노드가 `data` 속성과 `nextNode` 속성을 갖고 있다
- `class` 로 선언하므로, 참조타입이며, 참조 타입의 인스턴스는 힙 영역에 생성된다
	- 힙 영역의 인스턴스들은 그 인스턴스를 참조하는 다른 객체가 없다면, 즉, 총 해당 인스턴스의 참조가 0이라면 사라진다
		- [ ] ARC에 대해 공부하고 다시 한번 생각해볼 것
	- 따라서, `head = nil`을 쓰면 `head.nextNode`에 들어있던 두 번째 노드를 가리키는 객체가 없어지므로, 두 번째 노드는 사라지게 된다(메모리에서 해제된다고 말한다). 두 번째 노드가 사라지므로 세 번째 노드를 가리키는 객체가 없고, 그래서 세 번째 노드도 사라진다. 이게 연쇄적으로 작용하여 결국 모든 노드는 사라진다.

### Optional Binding - 참조 타입과 값 타입 관련
- 왜인지 모르겠지만 옵셔널 바인딩을 했을 때, unwrapped된 상수에는 `참조`가 아니라 `값`이 복사된다고 착각했다
- 즉, 아래 코드의 8번 줄에서의 `unwrapped`와 `minsson` 안에는 각각 다른 것이 들어있다고 착각했다
- 왜 이렇게 생각하고 있었을까? 혹시 `함수의 아규먼트로 들어온 값은 값 복사가 되어 들어온 것`이라는 개념과 헷갈린 걸까? 모르겠다.
```swift
class Person {
    var name = "민쏜"
}

let minsson: Person? = Person()

func printName() {
    guard let unwrapped = minsson else {
        return
    }
    
    print(unwrapped.name) // "민쏜"
    
    minsson?.name = "이름 변경됨"
    print(minsson?.name) // "이름 변경됨"
    print(unwrapped.name) // "이름 변경됨"
}

printName()
```


### 계산기 코드 리팩토링
##### 계산기에서 내가 작성했던 코드 (전)
```swift
    func removeFirstNode() -> Node<Element>? {
        if !isEmpty() {
            let removedNode = head ?? nil
            head = head?.nextNode
            return removedNode ?? nil
        }
        
        return nil
    }
```
- 불필요한 `nil-Coalescing` 반복, `nil` 반환만 3번
- 불필요한 `isEmpty()` 사용: 사실 `head`가 없으면 당연히 비어 있으므로 굳이 쓸 필요 없음
- `head`가 옵셔널이므로 `removedNode`로 `unwrapping`했지만, 정작 바로 아래에서는 그 값을 쓰지 않고 `head?.nextNode`라고 `optional chaining`을 사용

##### 함께 리팩토링한 코드 (후)
```swift
    func removeFirst() -> Node<Element>? {
        guard let removedNode = head else {
            return nil
        }
        
        head = removedNode.nextNode
        
        return removedNode
    }
```
- 깔-끔
